---
layout: post
title: 简单理解java虚拟机
author: Chris Rody菜鸟学习java虚拟机
---

##  JVM

### 1，基本问题

[本笔记de博客来源](https://juejin.im/post/5b7d69e4e51d4538ca5730cb)

---

> 基本问题：
>
> - **介绍下 Java 内存区域（运行时数据区）**
> - **Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）**
> - **对象的访问定位的两种方式（句柄和直接指针两种方式）**
>
> 拓展问题：
>
> - **String类和常量池**
> - **8种基本类型的包装类和常量池**

### 2，概述

虚拟机自动内存管理机制下，不易出现内存泄漏和溢出问题，这是因为java程序员把内存控制权交给了Java虚拟机，然而一旦出现内存溢出或泄漏，要求我们程序员必须清楚虚拟机是怎么使用内存的。

### 3，运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x1.png)

> 线程私有：程序计数器，虚拟机栈，本地方法栈
>
> 线程共享：堆，方法区，直接内存

##### 1，程序计数器（私）

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x2.png)

##### 2，虚拟机栈（私）

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x3.png)

##### 3，本地方法栈（私）

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x4.png)

##### 4，堆（公）

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x5.png)

##### 5，方法区（公）

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x6.png)

##### 6，运行时常量池（公）

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x7.png)

##### 7，直接内存

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x8.png)

### 4，Hotpot虚拟机对象

##### 4.1，创建过程

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x9.png)

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x11.png)

**内存分配的两种方式：（补充内容，需要掌握）**

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x10.png)

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x12.png)

##### 4.2，对象的内存布局

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x13.png)

建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

1，**句柄：** 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x14.png)

2，**直接指针：** 如果使用直接指针访问，那么 Java 堆对像的布局中就必须考虑如何防止访问类型数据的相关信息，reference 中存储的直接就是对象的地址。

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x15.png)

* 两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

### 5，重点补充

##### 5.1，String类和常量池

* String对象的两种创建方式

```java
     String str1 = "abcd";
     String str2 = new String("abcd");
     System.out.println(str1==str2);//false
```

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x16.png)

记住：**只要使用new方法，便需要创建新的对象**

##### 5.2，String 类型的常量池比较特殊，它的主要使用方法有两种：

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x17.png)

```java
	      String s1 = new String("计算机");
	      String s2 = s1.intern();
	      String s3 = "计算机";
	      System.out.println(s2);//计算机
	      System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，
	      System.out.println(s3 == s2);//true，因为两个都是常量池中的String对

```

* 字符串的拼接

```java
		  String str1 = "str";
		  String str2 = "ing";
		  
		  String str3 = "str" + "ing";//常量池中的对象
		  String str4 = str1 + str2; //在堆上创建的新的对象	  
		  String str5 = "string";//常量池中的对象
		  System.out.println(str3 == str4);//false
		  System.out.println(str3 == str5);//true
		  System.out.println(str4 == str5);//false
String s1 = new String("abc");//这句话创建了几个对象？
```

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x18.png)

* 经典问题：String s1 = new String("abc");这句话创建了几个对象？

```java
		String s1 = new String("abc");// 堆内存的地址值
		String s2 = "abc";
		System.out.println(s1 == s2);
		// 输出false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。
		System.out.println(s1.equals(s2));// 输出true

//所以创建了两个对象
```

**解释**：先有字符串"abc"放入常量池，然后 new 了一份字符串"abc"放入Java堆(字符串常量"abc"在编译期就已经确定放入常量池，而 Java 堆上的"abc"是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的"abc"。

##### 5.3，8种基本类型的包装类和常量池

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x19.png)

```java
		Integer i1 = 33;
		Integer i2 = 33;
		System.out.println(i1 == i2);// 输出true
		Integer i11 = 333;
		Integer i22 = 333;
		System.out.println(i11 == i22);// 输出false
		Double i3 = 1.2;
		Double i4 = 1.2;
		System.out.println(i3 == i4);// 输出false
```

Integer缓存源代码

```java
/**
*此方法将始终缓存-128到127（包括端点）范围内的值，不可以缓存此范围之外的其他值。
*/
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
```

应用场景,

1，Integer i1=40；Java 在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。

2，Integer i1 = new Integer(40);这种情况下会创建新的对象。

```java
  Integer i1 = 40;
  Integer i2 = new Integer(40);
  System.out.println(i1==i2);//输出false
```

Integer更经典问题

```java
  Integer i1 = 40;
  Integer i2 = 40;
  Integer i3 = 0;
  Integer i4 = new Integer(40);
  Integer i5 = new Integer(40);
  Integer i6 = new Integer(0);
  
  System.out.println("i1=i2   " + (i1 == i2));
  System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
  System.out.println("i1=i4   " + (i1 == i4));
  System.out.println("i4=i5   " + (i4 == i5));
  System.out.println("i4=i5+i6   " + (i4 == i5 + i6));   
  System.out.println("40=i5+i6   " + (40 == i5 + i6));   
  
  //控制台输出：
  i1=i2   true
  i1=i2+i3   true
  i1=i4   false
  i4=i5   false
  i4=i5+i6   true
  40=i5+i6   true
```

**解释**:语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。