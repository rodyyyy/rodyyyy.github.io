---
layout: post
title: java基础
author: Chris Rody
---

java基础知识点

##  java基础知识点记录

### 1，作用域public，private，protected，以及不写时的区别

![地址格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/java1.png)

> 实际上，把重要的数据修饰为private，然后写一个public的函数访问它，正好体现了OOP的封装特性，是OOP安全性的体现
>
> 访问权限修饰符修饰类时需要注意：
>
> 1、不能用protected和和private修饰类
>
> 2、用friendly修饰的类叫友好类，在另外一个类中使用友好类创建对象时，要保证它们在同一包中

### 2，关于String   s2=new   String( "Hello ")创建几个对象的分析

[借鉴的一篇经典博客解释](https://www.cnblogs.com/xuxinstyle/p/9345647.html)

> 视情况而定，当常量池中没有“Hello”对象时是创建两个，一个存放在常量池中，另一个存放在堆（内存）中（new String 产生）
>
> 并把这个堆内存中的String对象的引用返回给s2，String s2是栈中创建了的一个变量
>
> 如果是String s = "xyz"，那就要看常量池里有没有"xyz"，如果有直接引用，如果没有则创建再引用

### 3，==与equals

![地址格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/java2.png)

```java
public class test1 {
public static void main(String[] args) {
	String a = new String("ab"); // a 为一个引用
	String b = new String("ab"); // b为另一个引用,对象的内容一样
	String aa = "ab"; // 放在常量池中
	String bb = "ab"; // 从常量池中查找
		if (aa == bb) // true
			System.out.println("aa==bb");
		if (a == b) // false，非同一对象
			System.out.println("a==b");
		if (a.equals(b)) // true
			System.out.println("aEQb");
		if (42 == 42.0) { // true
			System.out.println("true");
     }
  }
}
```

![地址格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/java3.png)

### 4,抽象类和接口

[讲解得很好地一篇博客](https://blog.csdn.net/chenssy/article/details/12858267)

>  `抽象类`
>
>          1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。
>         
>          2、抽象方法必须由子类来进行重写。
>         
>          3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。
>         
>          4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。
>         
>          5、子类中的抽象方法不能与父类的抽象方法同名。
>         
>          6、abstract不能与final并列修饰同一个类。
>         
>          7、abstract 不能与private、static、final或native并列修饰同一个方法。、
> `接口`
>
>          1、个Interface的方所有法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！
>         
>          2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。
>         
>          3、接口中不存在实现的方法。
>         
>          4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。
>         
>          5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。
>         
>          6、在实现多接口的时候一定要避免方法名的重复。

###  5，重载和重写

##### **a,重载**

> 概念：对于同一个类，如果这个类里面有两个或者多个重名的方法，但是方法的参数个数、类型、顺序至少有一个不一样，这时候局构成方法重载
>
> 作用：方法重载就是对不同数据类型的的数据实现相似的操作
>
> 说明：在Test类中有两个方法，名字都相同，都是a。在调用方法a时，如果不传参数，则系统会自动调用第一个方法a；如果传入一个 int 类型的参数，则系统调用第二个方法a
>
>

```java
//example1
public class Test{  
  public void a( ){  
   };  
   public void a( int i){  
   };  
}  
//example2
public class Test{  
  public void a(int i,String j){  
  }  
  public class a(String j,int i){  
  }  
}  
```

##### **b,重写**

> 概念：当一个子类继承一父类，而子类中的方法与父类中的方法的名称，参数个数、类型都完全一致时，就称子类中的这个方法重写了父类中的方法。`重写也是覆盖 override`
>
> 前提：需要有继承关系
>
> 特点：当子类重写了父类的函数，那么子类的对象如果调用该函数，一定调用的是重写过后的函数；可以通过super关键字进行父类的重写函数的调用；继承可以使得子类增强父类的方法
>
> 细节：
>
>  1函数名必须相同
>
> 2参数列表必须相同
>
> 3子类重写父类的函数的时候，函数的访问权限必须大于等于父类的函数的访问权限否则编译报错
>
> 4子类重写父类的函数的时候，返回值类型必须是父类函数的返回值类型或该返回值类型的子类，不能返回比父类更大的数据类型

```java
//examples

class Animal{
	int x=1;
	String name;
	
	void eat(){
		System.out.println("吃东西");
	}
	void shout(){
		System.out.println("我是动物");
	}
}
 
class Dog extends Animal{
	
	
	void eat(){
		System.out.println("啃骨头");
	}
	void shout(){
		System.out.println("旺旺");
	}
	void eat(String food){
		System.out.println("吃："+food);
	}
}
class Cat extends Animal{
 
	void eat(){
		System.out.println("吃老鼠");
	}
	void shout(){
		System.out.println("喵喵");
	}
}
 
class Demo9{
 
	public static void main(String[] args){
		Dog d=new Dog();
		d.shout();
		d.eat();
		
		Cat c=new Cat();
		c.shout();
		c.eat();
		System.out.println();
     	}
//原文：https://blog.csdn.net/qq_32575047/article/details/79949823 
```

##### **c,重载和重写的不同**

> 1：重载(overload)：  
>
> 前提： 所有的重载函数必须在同一个类中
>
> 特点： 函数名相同，参数列表不同，与其他的无关(访问控制符、返回值类型)
>
> 不同：个数不同 、 顺序不同、 类型不同
>
>
>
> 重写(override)：
>
> 前提： 继承
>
>  特点：函数名必须相同、参数列表必须相同;子类的返回值类型要等于或者小于父类的返回值类型
>

##### **d,构造器能否被重写**

> 构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以根本谈不上继承
> 又由于构造器不能继承，所以就不能被重写。但是，在同一个类中，构造器是可以被重载的

### 6，List

> 1. 列表可包含任何数据类型的元素，单个列表中的元素无须全为同一类型。
> 2.  **append()** 方法向列表的尾部添加一个新的元素。
> 3.  列表是以类的形式实现的。“创建”列表实际上是将一个类实例化。因此，列表有多种方法可以操作。`extend()`方法只接受一个列表作为参数，并将该参数的每个元素都添加到原有的列表中。

### 7,forward和redirect的区别

**转发是服务器行为，重定向是客户端行为**

> **forward（转发）**：
>
> 是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,因为这个跳转过程是在服务器实现的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它的地址栏还是原来的地址.
>
> **redirect（重定向）**：
>
> 是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

### 8，多线程

![地址格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x22.png)