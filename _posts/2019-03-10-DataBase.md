---
layout: post
title: dataBase学习记录
author: Chris Rody
---

数据库笔记

##  dataBaseLearning

### 1，简单运用

```java
public class JdbcTest {

	public static void main(String[] args) {
		
		try {
	 Class.forName(Driver);//1,加载驱动
	 Connection con=DriverManager.getConnection(Url, UserName, UserPassword);
	 //2,通过驱动管理类创建数据库链接
	 String sql="select * from user where id=10";//3,设置sql语句
	 Statement statement=con.createStatement();//4,创建statement
	 //5，设置参数（这里暂时没有）
	 ResultSet resultset=statement.executeQuery(sql);
	 //6，执行查询，得到resultSet
	 //遍历resultSet，输出结果
	 while(resultset.next()) {
	 System.out.println(resultset.getString(1));
	 System.out.println(resultset.getString(2));
	 System.out.println(resultset.getString(3));
			}
		}
     con.close();//7，释放资源

		catch (SQLException e) {
			e.printStackTrace();
			}
		 catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
	}	
}

```

>Driver="com.mysql.cj.jdbc.Driver";   //新的MySQL驱动包，Driver类变化
>Url="jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8"
>UserName="root"
>UserPassword="rody123"

* 具体运行如下：

![表](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/数据库1.PNG)

![结果](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/数据库2.PNG)

### 2，常用命令

> SELECT COUNT(1) FROM `user`  ：计算列表的总记录数

>#{}：占位符，相当于jdbc的？
>
>${}：字符串拼接指令，如果入参为基本类型，{}内部只写value 

##### 1，往表中添加datetime类型的数据

```sql
insert into `order`
(user_id,number,createtime,note)
VALUES (29,5105,'2019-03-02 15:8:22' ,null),
(28,5589,'2017-03-02 15:2:6' ,null)
```

* 结果如下：

![结果](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/sql.png)

##### 2，查询navicat的版本

>select version() from dual;

### 3，索引

> `1,定义`
>
> 数据库[索引](http://baike.baidu.com/view/262241.htm)好比是一本书前面的目录，能加快数据库的查询速度。索引是对数据库表中一个或多个列（例如，employee 表的姓氏 (lname) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。

> `2.1优点`
>
> ```
> 1.大大加快数据的检索速度;   
> 2.创建唯一性索引，保证数据库表中每一行数据的唯一性;   
> 3.加速表和表之间的连接;   
> 4.在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。
> ```
> `2.2缺点`
>
>  ```
> 1.索引需要占用数据表以外的物理存储空间
> 2.创建索引和维护索引要花费一定的时间
> 3.当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。
>  ```



![SpEL](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/m1.png)

> `3,索引的分类`
>
> `3.1聚簇索引`
>
> ```
> 对于非聚簇索引表来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的地址。
> ```
>
> 优点：
>
> 1.当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。
> 2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。
>
> 缺点：
>
> 1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。
>  2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。
>  3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。
>  二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。
>  4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。
>
> `3.2非聚簇索引`
>
> ```
> 对于聚簇索引表来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)。
> ```
>
> `3.3唯一索引`
>
> ```
> 唯一索引：   UNIQUE     例如：create unique index stusno on student（sno）；
> 表明此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。
> ```
>
> `3.4主键索引`
>
> ```
> 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。
> ```
>
> `3.5覆盖索引`
>
> > 查找的目标数据， 包含在索引中，如建立idx_colum1_colum2.
>
> ```
> select colum1 from table where colum1 = ? and colum2 > ?
> ```
>
> 通过查询索引就能确定最终的数据，不用再利用叶子节点中存储的主键值去查询对应的数据。
>  覆盖索引的性能是极高的

> `4，索引的实现方式`
>
> `1 B+树`
> ​    我们经常听到B+树就是这个概念，用这个树的目的和红黑树差不多，也是为了尽量保持树的平衡，当然红黑树是二叉树，但B+树就不是二叉树了，节点下面可以有多个子节点，数据库开发商会设置子节点数的一个最大值，这个值不会太小，所以B+树一般来说比较矮胖，而红黑树就比较瘦高了。
> 关于B+树的插入，删除，会涉及到一些算法以保持树的平衡，这里就不详述了。ORACLE的默认索引就是这种结构的。
> 如果经常需要同时对两个字段进行AND查询,那么使用两个单独索引不如建立一个复合索引，因为两个单独索引通常数据库只能使用其中一个，而使用复合索引因为索引本身就对应到两个字段上的，效率会有很大提高。
>
> `2 散列索引`
> ​    第二种索引叫做散列索引，就是通过散列函数来定位的一种索引，不过很少有单独使用散列索引的，反而是散列文件组织用的比较多。
> 散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。
> 散列索引呢就是根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多了，也就是一种索引之上的二级辅助索引，我理解散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高。
>
> `3 位图索引`
> ​    位图索引是一种针对多个字段的简单查询设计一种特殊的索引，适用范围比较小，只适用于字段值固定并且值的种类很少的情况，比如性别，只能有男和女，或者级别，状态等等，并且只有在同时对多个这样的字段查询时才能体现出位图的优势。
> 位图的基本思想就是对每一个条件都用0或者1来表示，如有5条记录，性别分别是男，女，男，男，女，那么如果使用位图索引就会建立两个位图，对应男的10110和对应女的01001,这样做有什么好处呢，就是如果同时对多个这种类型的字段进行and或or查询时，可以使用按位与和按位或来直接得到结果了。
>
> B+树最常用，性能也不差，用于范围查询和单值查询都可以。特别是范围查询，非得用B+树这种顺序的才可以了。
> HASH的如果只是对单值查询的话速度会比B+树快一点，但是ORACLE好像不支持HASH索引，只支持HASH表空间。

参考博客：

[MySQL 数据库索引原理与分类](<https://www.jianshu.com/p/e1dce41a6b2b>)

[MySQL数据库索引的4大类型以及相关的索引创建](<http://database.51cto.com/art/201005/202796.htm>)

[数据库索引类型及实现方式](<https://blog.csdn.net/sdgihshdv/article/details/75039825>)

