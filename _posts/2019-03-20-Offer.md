---
layout: post
title: 算法之路
author: Chris Rody
---

算法记录

##  算法

### 1,二维数组的行和列

```java
int [][] array
//rows：array.length
//columes：array[0].length
//length是数组的一种属性，不用加（）
```



### 2.0,ArrayList总结

> ArrayList：动态数组类，ArrayList对象既有数组的特征，也有链表的特征；可以随时从中添加或者删除元素，ArrayList实现了接口类，可以动态改变大小
>
> Array：数组是静态的，数组被初始化后，长度不能改变
>
> 使用区分：当我们不知道到底有多少个数据元素的时候，就可使用ArrayList；如果知道数据集合有多少个元素，就用数组

``` java
ArrayList<String> list = new ArrayList<String>();//创建一个空的数组链表，用来存放String类型的对象
ArrayList<Integer> list = new ArrayList<Integer>(7);//创建一个指定初始容量的数组链表
```

* **ArrayList类只支持对象类型，不支持基础数据类型—>ArrayList对象只能存放对象，不能存放基础数据类型的数据。**

> `ArrayList常用方法`
>
> boolean add(Element e) //增加指定元素到链表尾部
>
> void add(int index, Element e) //增加指定元素到链表指定位置
>
> void clear() //从链表中删除所有元素
>
> E remove(int index) //删除链表中指定位置的元素
>
> protected void removeRange(int start, int end) //删除链表中从某一个位置开始到某一个位置结束的元素
>
> E get(int index) //获取链表中指定位置处的元素
>
> Object[] toArray() //获取一个数组，数组中所有元素是链表中的元素.（即将链表转换为一个数组）
>
> boolean contains(Object o) //如果链表包含指定元素，返回true
>
> int indexOf(Object o) //返回元素在链表中第一次出现的位置，如果返回-1，表示链表中没有这个元素
>
> int lastIndexOf(Object o) //返回元素在链表中最后一次出现的位置，如果返回-1，表示链表中没有这个元素
>
> boolean isEmpty() //返回true表示链表中没有任何元素
>
> int size() //返回链表长度（链表包含元素的个数）

``` java
//ArrayList使用实例
import java.util.*;

public class ArrayListExamples {

    public static void main(String args[]) {
        // 创建一个空的数组链表对象list，list用来存放String类型的数据
        ArrayList<String> list = new ArrayList<String>();

        // 增加元素到list对象中
        list.add("Item1");
        list.add("Item2");
        list.add(2, "Item3"); // 此条语句将会把“Item3”字符串增加到list的第3个位置。
        list.add("Item4");

        // 显示数组链表中的内容
        System.out.println("The arraylist contains the following elements: "
                + list);

        // 检查元素的位置
        int pos = list.indexOf("Item2");
        System.out.println("The index of Item2 is: " + pos);

        // 检查数组链表是否为空
        boolean check = list.isEmpty();
        System.out.println("Checking if the arraylist is empty: " + check);

        // 获取链表的大小
        int size = list.size();
        System.out.println("The size of the list is: " + size);

        // 检查数组链表中是否包含某元素
        boolean element = list.contains("Item5");
        System.out
                .println("Checking if the arraylist contains the object Item5: "
                        + element);

        // 获取指定位置上的元素
        String item = list.get(0);
        System.out.println("The item is the index 0 is: " + item);

        // 遍历arraylist中的元素

        // 第1种方法: 循环使用元素的索引和链表的大小
        System.out
                .println("Retrieving items with loop using index and size list");
        for (int i = 0; i < list.size(); i++) {
            System.out.println("Index: " + i + " - Item: " + list.get(i));
        }

        // 第2种方法:使用foreach循环
        System.out.println("Retrieving items using foreach loop");
        for (String str : list) {
            System.out.println("Item is: " + str);
        }

        // 第三种方法:使用迭代器
        // hasNext(): 返回true表示链表链表中还有元素
        // next(): 返回下一个元素
        System.out.println("Retrieving items using iterator");
        for (Iterator<String> it = list.iterator(); it.hasNext();) {
            System.out.println("Item is: " + it.next());
        }

        // 替换元素
        list.set(1, "NewItem");
        System.out.println("The arraylist after the replacement is: " + list);

        // 移除元素
        // 移除第0个位置上的元素
        list.remove(0);

        // 移除第一次找到的 "Item3"元素
        list.remove("Item3");

        System.out.println("The final contents of the arraylist are: " + list);

        // 转换 ArrayList 为 Array
        String[] simpleArray = list.toArray(new String[list.size()]);
        System.out.println("The array created after the conversion of our arraylist is: "
                        + Arrays.toString(simpleArray));
    }
}
```

* **ArrayList有三种遍历方式**

```java
//迭代器遍历
Iterator<Integer> it = arrayList.iterator();
while(it.hasNext()){
    System.out.print(it.next() + " ");
}

//索引值遍历
for(int i = 0; i < arrayList.size(); i++){
   System.out.print(arrayList.get(i) + " ");
}

//for循环遍历
for(Integer number : arrayList){
   System.out.print(number + " ");
}
//遍历效率：索引值最高，for循环次之，迭代器最低
```

* **toArray的使用**

> 当我们调用ArrayList中的 toArray()，遇到java.lang.ClassCastException异常，这是由于toArray() 返回的是 Object[] 数组
>
> 将 Object[] 转换为其它类型(如，将Object[]转换为的Integer[])则会抛出java.lang.ClassCastException异常，因为Java不支持向下转型 

```java
 // toArray用法
 // 第一种方式(最常用)
 Integer[] integer = arrayList.toArray(new Integer[0]);

 // 第二种方式(容易理解)
 Integer[] integer1 = new Integer[arrayList.size()];
 arrayList.toArray(integer1);

 // 抛出异常，java不支持向下转型
 //Integer[] integer2 = new Integer[arrayList.size()];
 //integer2 = arrayList.toArray();
```

##### Array和ArrayList的区别：

ArrayList内部是由一个Array实现的，`ArrayList` 是Java集合框架类的一员,可以称它为一个动态数组. `array` 是静态的,所以一个数据一旦创建就无法更改他的大小, 所以, 如果需要一个数组可以重新定义他的大小,你应该使用 `ArrayList`, 这是`array` 和`ArrayList`的基本的不同。

* Implementation 实现

`array` 是本地的程序设计组件或者数据结构,但是`ArrayList`是一个来自Java集合类的类,一个接口 (Application programming interface). 实际上,`ArrayList` 在Java上,它的内部是由一个`array`实现的. 既然`ArrayList`是一个类,所以它持有了所有类的属性.例如,你可以创建对象,可以调用方法,但`array`并不提供任何方法. 它仅仅暴露了一个常量的长度来表示当前数组的长度。

* Performance 性能

既然`ArrayList`是基于`array`,所以你可能会认为它提供和`array`一样的性能. 这个假设在一定程度上是成立的,但是在一些额外功能性的`ArrayList`上性能还是和`array` 存在一定差别, 主要是内存的使用和CPU 耗时. 在索引上,`ArrayList`和`array`都能提供O(1)的时间复杂度,但是在添加item的时候如果出发resize,`ArrayList`可能会是O(logN)的时间复杂度,因为它包含了创建一个新的`array` 和[将老的`array`的数据拷贝到新的`array`里](http://javarevisited.blogspot.com.au/2011/06/converting-%60array%60-to-%60ArrayList%60-in-java.html). 在存储相同数量的对象时,`ArrayList`所需要的内存也是比`array`大的. 例如一个int[] 的数组会比`ArrayList`节省20个int 变量的大小,因为对象的基本数据会在`ArrayList`和包装类上进行开销.

* Type Safety 类型安全

`ArrayList` 是类型安全的,因为它支持泛型(Generics) 允许编译器检查 `ArrayList` 里所包含的对象是否是正确的类型.然而, `array` 并不支持泛型.这代表在编译时期检查`array` 所保存对象的类型是不可能的,但是`array` 通过抛出 `ArrayStoreException` 异常的方式来进行运行时的类型检查如果你存储了一个错误类型的对象,例如,`存储一个String` 到 `int` `array` 里

* Flexibility 灵活性

灵活性是区分`array` 和 `ArrayList`最重要的一个东西,简单来说,`ArrayList`比简单的`array`要灵活的多,因为 `ArrayList` 是动态的,它可以在需要的时候扩大自己的内存,这是一个 `array` 不可能做到的.`ArrayList` 也允许你删除元素, 这在`array`上也是不可能的.通过删除,我的意思并不是将null置于对应的index里,而是将所删除元素的后面所有元素的index都往前移动一位,这些都是`ArrayList`自动为我们做的.你可以从我的文章里学到更多关于从`ArrayList`里删除对象[difference between clear() and removeAll()](http://javarevisited.blogspot.com/2015/09/how-to-reset-%60ArrayList%60-in-java-clear-vs-removeAll-example.html)

* Primitives 基本类型

如果你第一次开始使用Arraylis,你会发现,你不能保存基本类型到`ArrayList`里,这是`array`和`ArrayList`一个关键的不同,因为`array`既可以保存对象也可以保存基本类型.例如.int[]数组是合法的,但是一个int型的`ArrayList`是不合法的. 如何解决这个问题呢? 假设你想存储int类型到`ArrayList`里,你会怎么做呢? 是的,你可以用封装类,这就是封装类被引进java的原因之一.所以,从java5开始,这个区别越来越不明显了,因为通过自动封装你会发现``ArrayList`.add(21)`是非常合法并且运行正常.

* Generics 泛型

`ArrayList`和`array`之间的另外一个重要的区别就是前者能够显示的支持泛型,后者不行.由于数组是协变性的,所以你可以在`array`上使用泛型(`Since an `array` is of covariant type, you can use Generics with them`).这个表示编译器不可能检查`array`的类型安全,但是可以校验类型安全.当你要写一个类型安全的类的时候如何解决这个问题呢?好吧,你可以用里展示的技术,通过申明一个类似于E[]的数组,然后后期进行类型转换.

* Iteration 迭代

`ArrayList` 提供比`array`更多的方式来迭代一个接一个的访问所有的元素.可以通过for,while等循环来遍历`array`,但是你可以通过`Iterator` 和`ListIterator`类来遍历`ArrayList`.看[这里](http://java67.blogspot.com/2012/08/how-to-traverse-iterate-or-loop-%60ArrayList%60-in-java-example-tutorial.html)来了解更多的遍历`ArrayList`的方式.

* Supported Operations 支持的操作

由于`ArrayList`的内部是由一个`array`支撑着,所以它暴露了能够在`array`可能支持的操作,并且还提供了它动态的属性.它也支持添加操作,这是在`array`上不可能的.你可以同时在`array`和`ArrayList`上存储元素,但是仅`ArrayList`允许你删除元素.然而你可以通过模拟将null赋值到对应的index里来模拟删除.这个模拟不会像是删除,除非你同时将所删除元素对应的索引(index)移动到下一级

```
ArrayList`和`array`头提供取元素的方法.例如`ArrayList`用索引通过get()方法来获取一个元素, version[0]将会返回`array`的第一个元素.`ArrayList`也提供一个方法来清空和重用例如,`clear()` 和 `removeAll()`.`array`并不提供那些方发,但是你可以通过循环这个数组来将null赋值到所有的元素里来模拟`ArrayList`的`removeAll()
```

* Size() vs length 大小 vs 长度

`array` 仅仅提供一个`length` 属性来告诉你`array`里有多少个插槽,例如可以存储多少个元素.它没有提供任何方法来告诉你哪些插槽是满的,哪些是空的.例如,当前元素的个数.但是`ArrayList`提供一个`size()`方法来告诉你当前时间点`ArrayList`存储了多少个元素.`size()` 总是和`length`不同的,它也是`ArrayList`的容量.如果你想知道更多关于这个的知识,我建议你阅读这篇文章文章[`array` length vs `ArrayList` Size in Java](http://java67.blogspot.com/2014/04/%60array%60-length-vs-%60ArrayList%60-size-java.html)

* Dimension 维度

`ArrayList`和`array`的另外一个重要的区别就是`array`可以使多维度的.例如,你可以设置一个二维数组或者三维数组.可以使你创在一个特殊的数据结构来代表矩阵或者2D形式(`terrains`),另一方面,`ArrayList`并不支持允许你指定维度.请参见[这个指导](http://java67.blogspot.com/2014/10/how-to-create-and-initialize-two-dimensional-%60array%60-java-example.html)来学习更多关于如何在Java里使用多维度的数组.

这里是列出了所有`ArrayList`和`array`的重要区别![difference](http://7fvfrr.com1.z0.glb.clouddn.com/Difference%20between%20Array%20vs%20%60ArrayList%60%20in%20Java.png)

`相似之处`

1) Data Structure 数据结构

两者都允许你存数对象,并且所有的都是基于index的数据结构,提供O(1)的复杂度来获取一个元素,但是如果通过[二分查找](http://javarevisited.blogspot.com/2014/03/binary-search-vs-contains-performance.html)来查询某个元素依旧需要log(N)的复杂度.

2) Order 顺序(没太理解这句话的意思)

Both `array` and `ArrayList` maintains order on which elements are added into them. (`array`和`ArrayList`都保持着元素的顺序?)

3) Search 查找

你可以通过index来查找一个元素,这个是O(1)的时间复杂度,除此之外如果你的`array`不是排好序的数组你可以用线性的查找,这个将消耗大约O(n)的时间复杂度,或者你可以将数组排序后使用二分查找,这个将消耗排序的时间复杂度加上O(logN)

4) Null values 空值

`array` 和 `ArrayList`都允许存储null值,但请记住只有object的`array`可以这样,基本类型的数组会存储他们的默认值,例如int型的数组默认存储0,boolean的数组默认存储false.

5) Duplicates 重复

`array`和Arraylis都允许存储重复的值,

6) Performance 性能

`ArrayList`模仿`array`的性能,例如O(1)复杂度的访问元素如果你知道这个元素的index,但是`ArrayList`会消耗更多的内存,因为它是存储的对象,并且持有了而外的数据来自动更改`ArrayList`的长度.

7) Zero-based Index

这些就是关于`array`和`ArrayList`的所有不同点啦,其中你需要记住的最重要的不同点就是`array`是静态的,你无法一旦创建了一个数组就无法更改它的大小,但是`ArrayList`因为是动态的,所以它可以做到.根据这个不同点,如果你事先知道数组的长度,并且确定它的大小不会改变,你应该使用`array`,否则请使用`ArrayList`吧

### 2.1,vector数组

> Vector 可实现自动增长的对象数组
> java.util.vector提供了**向量类(vector)**以实现类似动态数组的功能。事实上，灵活使用数组也可以完成向量类的功能，但向量类中提供大量的方法大大方便了用户的使用。 
> ​        创建了一个向量类的对象后，可以往其中随意插入不同类的对象，即不需顾及类型也不需预先选定向量的容量，并可以方便地进行查找。对于预先不知或者不愿预先定义数组大小，并且需要频繁地进行查找，插入，删除工作的情况。可以考虑使用向量类。 

`插入功能`

> (1)adddElement(Object obj) 
> 将obj插入向量的尾部，**obj可以是任何类型的对象**。对同一个向量对象，亦可以在其中插入不同类的对象。但插入的应是对象而不是数值，所以插入数值时要注意将数组转换成相应的对象。 
>
> ```java
> //例如：要插入整数1时，不要直接调用v1.addElement(1),正确的方法为： 
> Vector v1 = new Vector(); 
> Integer integer1 = new Integer(1); 
> v1.addElement(integer1); 
> ```
>
> (2)setElementAt(Object obj,int index) 
> 将index处的对象设置成obj，原来的对象将被覆盖。 
> (3)insertElement(Object obj,int index) 

`删除功能`

> (1)removeElement(Object obj) 
> 从向量中**删除obj**,若有多个存在，则从向量头开始试，删除找到的第一个与obj相同的向量成员。 
> (2)removeAllElement(); 
> 删除向量所有的对象 
> (3)public fianl synchronized void removeElementAt(int index) 

`查询搜索功能`

> (1)indexOf(Object obj) 
> 从向量头开始搜索obj,返回所遇到的第一个obj对应的下标，若不存在此obj,返回-1. 
> (2)indexOf(Object obj,int index) 
> 从index所表示的下标处开始搜索obj. 
> (3)lastindexOf(Object obj) 
> 从向量尾部开始逆向搜索obj. 
> (4)lastIndex(Object obj,int index) 
> 从index所表示的下标处由尾至头逆向搜索obj. 
> (5)firstElement() 
> 获取向量对象中的首个obj 
> (6)lastElement() 
> 获取向量对象中的最末obj

`例子`

```java
import java.util.Vector; 
import java.lang.*; 
import java.util.Enumeration; 
public class VectorApp 
{ 
     public static void main(String args[]) 
     { 
          Vector v1 = new Vector(); 
          Integer integer1= new Integer(1); 
          //加入为字符串对象 
          v1.addElement("one"); 
          //加入的为integer的对象 
          v1.addElement(integer1); 
          v1.addElement(integer1); 
          v1.addElement("two"); 
          v1.addElement(new Integer(2)); 
          v1.addElement(integer1); 
          v1.addElement(integer1); 
          //转为字符串并打印 
            System.out.println("The Vector v1 is:\n\t"+v1); 
          //向指定位置插入新对象 
          v1.insertElement("three",2); 
          v1.insertElement(new Float(3.9),3); 
          System.out.println("The Vector v1(used method 
          insertElementAt()is:\n\t)"+v1); 
          //将指定位置的对象设置为新的对象 
            //指定位置后的对象依次往后顺延 
            v1.setElementAt("four",2); 
           System.out.println("The vector v1 cused method setElmentAt()is:\n\t"+v1); 
           v1.removeElement(integer1); 
           //从向量对象v1中删除对象integer1 
           //由于存在多个integer1,所以从头开始。 
             //找删除找到的第一个integer1. 
           Enumeration enum = v1.elements(); 
           System.out.println("The vector v1 (used method removeElememt()is"+v1); 
            while(enum.hasMoreElements()) 
            System.out.println(enum.nextElement()+""); 
            System.out.println(); //隔行
            //使用枚举类(Enumeration)的方法取得向量对象的每个元素。 
              System.out.println("The position of Object1(top-to-botton):"+v1.indexOf(integer1)); 
            System.out.println("The position of Object1(tottom-to-top):"+v1.lastIndexOf(integer1)); 
            //按不同的方向查找对象integer1所处的位置 
              v1.setSize(4); 
            System.out.println("The new Vector(resized the vector)is:"+v1); 
            //重新设置v1的大小，多余的元素被抛弃    
     } 
} 
```

`结果`

```
The vector v1 is:
[one,1,1,two,2,1,1] 
The vector v1(used method insetElementAt()) is: 
[one,1,three,3.9,1,two,2,1,1] 
The vector v1(used method setElementAt()) is: 
[one,1,four,3.9,1,two,2,1,1] 
The vector v1(useed method removeElement()) is: 
[one,four,3.9,1,two,2,1,1] 
The position of object1(top-to-botton):3 
The position of object1(botton-to-top):7 
The new Vector(resized the vector) is: 
[one,four,3.9,1] 
```

[此处参考博文](https://blog.csdn.net/listening_music/article/details/7034070 )

`补充`

> (1)类vector定义了方法 size(); 
> 此方法用于获取向量元素的个数。它们返回值是向量中实际存在的元素个数，而非向量容量。可以调用方法capacity()来获取容量值
>
> setsize(int newsize); 
> 此方法用来定义向量的大小，若向量对象现有成员个数已经超过了newsize的值，则超过部分的多余元素会丢失。 
> (2)程序中定义Enumeration类的一个对象Enumeration是java.util中的一个接口类， 
> 在Enumeration中封装了有关枚举数据集合的方法。 
> hasMoreElement()来判断集合中是否还有其他元素和方法
> nextElement()来判断集合中是否还有其他元素
> nextElement()来获取下一个元素,利用这两个方法，可以依次获得集合中的元素。 
> Vector中提供方法： 
> public final synchronized Enumeration elements(); 

### 2.2，java中Map,List与Set的区别

参考：[java中Map,List与Set的区别](<https://blog.csdn.net/SpeedMe/article/details/22398395>)

> `一、关系`
>
> Collection
> --List：以特定顺序存储
> --ArrayList、LinkList、Vector
> --Set：不能包含重复的元素
> --HashSet、TreeSet
>
> Map
> --HashMap、HashTable、TreeMap
>
> `二、分别讲解`
>
> Collection：Collection是一个父接口，List和Set是继承自他的子接口，Collection是最基本的集合接口，Java JDK中不提供直接继承自Collection的类，而是提供继承自他子接口的类，如List和Set。所用的Collection类都支持一个Iterator()方法来遍历。
>
> List：List接口是有序的，会精确的将元素插入到指定的位置，和下面的Set接口不同，List接口允许有相同元素
>
> ArrayList：实现可变大小的数组，允许所有的元素，不是同步的，也就是没有同步方法
>
> LinkList：允许null元素，通常在首部或者尾部操作，所以常被使用做堆栈(stack)、队列(queue)和双向队列(deque)
>
> Vector：类似于ArrayList，但Vector是同步的，Stack继承自Vector
>
> Set：是一种不包含重复元素的Collection接口
>
> HashSet：不能有重复元素，底层是使用HashMap来实现的
>
>
>
> Map：此接口实现的Key到Value的映射，一个Map中不能包含相同的Key，每个Key只能映射一个Value
>
> HashTable：实现了一个Key-Value的哈希表，每一个非null元素都可作为Key或者Value，HashTable是同步的
>
> HashMap：非同步的，且允许null元素的存在
>
> TreeMap:
>
> SortedMap:
>
> [map的典型：map的输出](<https://www.jianshu.com/p/32d1fea29145>)
>
> `三、Array和Arrays  Collection和Collections`
>
> Array：是所以随机访问一串对象中，最有效率的一种，但是元素类型必须相同，且容量固定无法改变。
>
> Arrays：此静态类专门操作array，提供搜索、排序、复制等静态方法
>
> Collection：Java.util下的一个接口，是各种集合结构的父接口
>
> Collections：Java.util下的一个专用静态类，他包含各种集合操作的静态方法，包括对集合的搜索、排序、线程安全等操作。
>
> 四、总结
> 涉及到堆栈、队列等操作，使用List接口，快速插入和删除应使用LinkList，随机访问元素使用ArrayList单线程使用非同步类，多线程使用同步类
>
> 注意对HashTable的操作，作为Key的对象要覆写equals和hashCode方法
>
> 在各种Map中HashMap用于快速查找最常使用的是ArrayList、HashSet、HashMap、Array

##### 2.2.1 迭代器iterator的使用

`迭代器（Iterator）`

　　迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。
​       	Java中的Iterator功能比较简单，并且只能单向移动：

> (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。
>
> (2) 使用next()获得序列中的下一个元素。
>
> (3) 使用hasNext()检查序列中是否还有元素。
>
> (4) 使用remove()将迭代器新返回的元素删除。
>
> Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，
>
> 也可以从List中插入和删除元素。

`迭代器应用：`

```java
 list l = new ArrayList();
 l.add("aa");
 l.add("bb");
 l.add("cc");
 for (Iterator iter = l.iterator(); iter.hasNext();) {
  String str = (String)iter.next();
  System.out.println(str);
 }
 /*迭代器用于while循环*/
 Iterator iter = l.iterator();
 while(iter.hasNext()){
  String str = (String) iter.next();
  System.out.println(str);
 }
```



### 3,栈的操作

```
Stack<Integer> stack = new Stack<Integer>();//堆栈的定义
```

* 两个栈操作的范例

```java
//两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
        
    }
    
    public int pop() {
        while(!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        int res=stack2.pop();
        while(!stack2.isEmpty()){
            stack1.push(stack2.pop());
        }
        return res;
    }
}
```

```java
import java.util.*;

public class StackTest {
    /**
     * @param args
     */
    public static void main(String[] args) {
        Stack stack = new Stack(); // 创建堆栈对象 
        System.out.println("11111, absdder, 29999.3 三个元素入栈"); 
        stack.push(new Integer(11111)); //向 栈中 压入整数 11111
        printStack(stack);  //显示栈中的所有元素
 
 
        stack.push("absdder"); //向 栈中 压入
        printStack(stack);  //显示栈中的所有元素
 
        stack.push(new Double(29999.3)); //向 栈中 压入
        printStack(stack);  //显示栈中的所有元素
 
        String s = new String("absdder");
        System.out.println("元素absdder在堆栈的位置"+stack.search(s));      
        System.out.println("元素11111在堆栈的位置"+stack.search(11111));
 
        System.out.println("11111, absdder, 29999.3 三个元素出栈"); //弹出 栈顶元素 
        System.out.println("元素"+stack.pop()+"出栈");
        printStack(stack);  //显示栈中的所有元素
        System.out.println("元素"+stack.pop()+"出栈");
        printStack(stack);  //显示栈中的所有元素
        System.out.println("元素"+stack.pop()+"出栈");
        printStack(stack);  //显示栈中的所有元素
    }
 
    private static void printStack(Stack<Integer> stack ){
        if (stack.empty())
            System.out.println("堆栈是空的，没有元素");
            else {
                System.out.print("堆栈中的元素：");
                Enumeration items = stack.elements(); // 得到 stack 中的枚举对象 
                while (items.hasMoreElements()) //显示枚举（stack ） 中的所有元素
                    System.out.print(items.nextElement()+" ");
            }
        System.out.println(); //换行
    }
    
    //使用for循环的方式遍历栈是很方便的（第二种方法）
    private static void printStack2(Stack<Object> stack ){
        if (stack.empty())
            System.out.println("堆栈是空的，没有元素");
            else {
                System.out.print("堆栈中的元素：");
                for(Object o: stack){
                <span style="white-space:pre">	</span> System.out.print(o+" ");
                }
        System.out.println(); //换行
       }
    }
}
/*
运行结果
11111, absdder, 29999.3 三个元素入栈

堆栈中的元素：11111

堆栈中的元素：11111 absdder 

堆栈中的元素：11111 absdder 29999.3 

元素absdder在堆栈的位置2

元素11111在堆栈的位置3

11111, absdder, 29999.3 三个元素出栈

元素29999.3出栈

堆栈中的元素：11111 absdder 

元素absdder出栈

堆栈中的元素：11111 

元素11111出栈

堆栈是空的，没有元素   */
```

### 3,数二进制中1的个数

* 两种方法

```java
//>>>代表逻辑右移，int占4个字节共32位，因此移位32次
public int 1NumberOf1(int n) {
		int count = 0;
        for(int i = 0; i < 32; i++){
            if((n >>> i & 1) == 1)
                ++count;
        }
        return count;
    }
//二进制数循环减一，并与自身相与，记录直到n为0相减的次数即为1的个数
public int 2NumberOf1(int n) {
        int count = 0;
        if(n == 0)
            return count;
		while(n != 0){
         	++count;
            n = (n-1) & n;
        }
        return count;
    }
```

### 4,数组中奇偶数的处理

>  输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

```java
 public void reOrderArray(int [] array) {
         int j = 0;//定位需要确定位
	        for(int i = 0;i<array.length;i++){
	            if(array[i]%2==1){
	            	//如果是奇数的话
	            	if(i!=j){
	            		int temp = array[i];
	            		int k = i;
	            		for(k = i;k>j;k--){
	            			array[k]=array[k-1];//遇到一个奇数，依次将其移动到偶数前面
	            		}
	            		array[k]=temp;//把奇数的值填入
	            		
	            	}
	            	
						j++;
					
	            }
	        }
    }
```

### 5,输出链表节点

> 输入一个链表，输出该链表中倒数第k个结点
>
> `思路`
>
> 代码思路如下：两个指针，先让第一个指针和第二个指针都指向头结点，然后再让第一个指正走(k-1)步，到达第k个节点。然后两个指针同时往后移动，当第一个结点到达末尾的时候，第二个结点所在位置就是倒数第k个节点了  

```java
public ListNode FindKthToTail(ListNode head,int k) {
        if(head==null||k<=0){
            return null;
        }
        ListNode pre=head;
        ListNode last=head;
        for(int i=1;i<k;i++){//例如倒数第二个，pre和last索引相差1
            if(pre.next!=null){
                pre=pre.next;
            }
            else {return null;}
        }
        while(pre.next!=null){
            pre=pre.next;
            last=last.next;
        }
        return last;
    }
```

### 6,反向链表

> 输入一个链表，反转链表后，输出新链表的表头
>
> `思路1`
>
> 链表的反转 等价于反转链表的指针，只要把原链表中的指针反转，便是链表的反转
>
> /*
> 当middle指针指向的节点不为空时，我们需要用after来保存它下一个节点，防止链表断开后，无法继续后移。middle的next指向pre实现反序，然后middle和pre同时后移一步即可，此时middle指向下一个待考察的节点，直到middle指向空为止，说明链表已完成反序操作。
> */

```java
public ListNode ReverseList(ListNode head) {
        //pre始终指向已反序的最后一个节点
        ListNode pre = null;
        //middle始终指向正在考察节点
        ListNode middle = head;
        //after始终指向待反序的第一个节点，也就是middle之后
        ListNode after = null;
        while(middle != null) {
            //更新after
            after = middle.next;
            //对考察的节点进行反序
            middle.next = pre;
            //更新pre
            pre = middle;
            //后移middle, 换下一个待考察节点
            middle = after;
        }
        //因为pre始终指向已反序的最后的一个节点
        return pre;
    }

```

> `思路2`
>
> 还是上面的想法，只不过我们这次充分利用head来代替middle作用，我们赋予head新的语义，使其始终指向已完成反序的最后一个节点

```java
    /**
     * 充分利用head指针和外加2个辅助指针
     
     */
    public static ListNode ReverseList2(ListNode head) {
        ListNode pre = null;
        ListNode after = null;
        while(head != null) {
            after = head.next;
            head.next = pre;
            pre = head;
            head = after;
        }
        return pre;
    }

```

> `思路3`
>
> 我们使其先走到链表的末尾，确保每次回溯时都返回最后一个节点的指针。同时从倒数第二个结点开始反序。
> head.next.next = head; 是指使当前节点的下一个节点指向自己
> head.next = null; 断开与下一个节点的联系，完成真正的反序操作

```java
    /**
     * 牛逼的递归实现
     */
    public static ListNode ReverseList3(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode reverseHead = ReverseList3(head.next);
        head.next.next = head;
        head.next = null;
        return reverseHead;
    }

```

[参考出处](<https://blog.csdn.net/dawn_after_dark/article/details/80765535>)

> `另外一个简单的理解`
>
> 思路：
> 链表的反转 等价于反转链表的指针，只要把原链表中的指针反转，便是链表的反转
> 比如 原链表中 head指向head.next，先把head.next保存起来（不然改变head的指向后，原链表会断开，找不到下一个节点），然后改变head指向result（新建节点），再用result表示新链表的表头
> 1>2>3>4
>
> 1(result) 2>3>4
>
> 1<2(result) 3>4
>
> 1<2<3(result) 4
>
> 1<2<3<4(result) 

### 7,斐波那契数列

##### 1，数列

> 斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“[兔子数列](https://baike.baidu.com/item/%E5%85%94%E5%AD%90%E6%95%B0%E5%88%97/6849441)”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：
>
> F(1)=1,F(2)=1, 
>
> F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）

##### 2，一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法

![01patch](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x20.png)

```java
 //自己的简单解法
 public int JumpFloor(int target) {
        if(target==1){
            return 1;
        }
         if(target==2){
            return 2;
        }
        while(target>2){
            return JumpFloor(target-1)+JumpFloor(target-2);
        }return 0;
    }
```

##### 3，延伸

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法
>
> 思路：斐波那契的延伸，n为1,2,3时对应的跳法为1,2,4，当n>3时，跳数等于前n-1中情况的所有跳数之和

![01patch](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/x21.png)

```java
public int JumpFloorII(int target) {
        int count=0;
        while(target>0){
              switch(target){
            case 1:return 1;
            case 2:return 2;
            case 3:return 4;
            default :{
                for(int n=target-1;n>0;n--){
                    count+=JumpFloorII(n);
                }return count+1;
            }
        }
        }
        return 0;
    }
```

### 8,合并链表

> 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

`方法一：构造一个第三链表装入`

```java
 public ListNode Merge(ListNode list1,ListNode list2) {
     ListNode head = new ListNode(0); // 指向新链表的头结点的虚头结点，方便最后的返回
        ListNode tempNode = null;// 排序链表中的前锋指针，指向新链表的最后一个元素。

        // 判断是否为null
        if (list1 == null) {
            return list2;
        } else if (list2 == null) {
            return list1;
        }

        // 判断开头
        if (list1.val <= list2.val) {
            head.next = list1;
            list1 = list1.next;
        } else {
            head.next = list2;
            list2 = list2.next;
        }
        tempNode = head.next;

        // 该while 外层循环一直执行的前提，在于两个链表都没有循环到各自最后的null
        while (true) {

            // list1不为空，且值不大于list2的值
            while (list1 != null && list1.val <= list2.val) {
                tempNode.next = list1;
                tempNode = list1;//这里的tempNode需要一直紧跟最后的一个元素
                list1 = list1.next;
            }
            // 如果list1循环完了，那就直接退出
            if (list1 == null) {
                break;
            }

            while (list2 != null && list2.val <= list1.val) {
                tempNode.next = list2;
                tempNode = list2;
                list2 = list2.next;
            }
            if (list2 == null) {
                break;
            }
        }
        // 把剩余的那部分统一拼接到最后
        if (list1 == null) {
            tempNode.next = list2;
        } else {
            tempNode.next = list1;
        }

        return head.next;
     }
```

`方法二：递归`

 ```java
 public ListNode merge1(ListNode list1, ListNode list2) {
        if (list1 == null) {
            return list2;
        }
        if (list2 == null) {
            return list1;
        }

        ListNode listNode = null;
        if (list1.val <= list2.val) {
            listNode = list1;
            listNode.next = merge1(list1.next, list2);
        } else {
            listNode = list2;
            listNode.next = merge1(list1, list2.next);
        }

        return listNode;
    }
 ```

### 9,数学题

##### 1，求1+2+3+...+n，要求不能使用乘除法等

> 要求：不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）

```java
public class Solution {
    public int Sum_Solution(int n) {
        int count=n;
        boolean i=(n>0)&&(count+=Sum_Solution(n-1))>0;
        return count;
    }//这里用boolean对整个式子的值进行判断，即可对递归进行运算，然后得到最后的总和
}·
```

##### 2，两个整数之和，不得使用+、-、*、/

> 分析：因为不能使用加减乘除，因此只能位运算
>
> 两数相加：只有同为1时有进位，这种情况用&来筛选；
>
> ​                   只有1，0相加为1，这种情况用异或来筛选；
>
> ​                   进位的处理，则对数字进行左移之后再进行异或

```java
 public int Add(int num1,int num2) {
         
        while(num2!=0){
           int bitXor=num1^num2;//异或就相当于不进位的和：1+1=0；
           int bitAnd=num1&num2;//相与就相当于标记出进位
            num1=bitXor;
            num2=bitAnd<<1;
        }return num1;
    }
```

### 10,字符串格式数字输出

> 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数

```java
 public int StrToInt(String str) {
        int flag=0;
        if(str.length()==0)
            return 0;
        else if(str.charAt(0)=='+'){
            flag=1;
        }
        if(str.charAt(0)=='-'){
            flag=2;
        }
        int start=flag>0?1:0;
        long res=0;//这里用double也不行，只能用同时整形的long
       while(start<str.length()){
           if(str.charAt(start)<'0'||str.charAt(start)>'9'){
               return 0;
           }
           res=res*10+(str.charAt(start)-'0');
           start++;
       }
        return flag>1?-(int)res:(int)res;//没有+，-或者直接没有符号的情况
    }
```

### 11，二叉树

##### 1，树之间的子结构关系

> 题目：输入两棵二叉树A，B，判断B是不是A的子结构
>
> ps：我们约定空树不是任意一个树的子结构
>
> 思路：判断根的值是否相等，若等则进行俩结构的匹配，若相同就是子结构；若不同则用root1的左子树、右子树跟root2进行递归查询；注意在进行操作之前的if判断的几种类型

```java
/**
public class TreeNode {//树的每一个节点的结构
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        // 只要树B的根结点点为空就返回false
        if (root2 == null) {
            return false;
        }
        // 树B的根结点不为空，如果树A的根结点为空就返回false
        if (root1 == null) {
            return false;
        }
        if (root1 == root2) {
            return true;
        }
        // 记录匹配结果
        boolean result = false;
        // 如果结点的值相等就，调用匹配方法，看是否两个为跟的结构是否是相同的
        if (root1.val == root2.val) {
            result = match(root1, root2);
        }
        // 如果匹配就直接返回结果
        if (result) {
            return true;
        }
        // 如果不匹配就找树A的左子结点和右子结点进行判断
        return HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
        
    }
    public static boolean match(TreeNode root1,TreeNode root2) {
        // 只要两个对象是同一个就返回true
        if (root1 == root2) {
            return true;
        }
        // 只要树B的根结点点为空就返回true
        if (root2 == null) {
            return true;
        }
        // 树B的根结点不为空，如果树A的根结点为空就返回false
        if (root1 == null) {
            return false;
        }
        // 如果两个结点的值相等，则分别判断其左子结点和右子结点
        if (root1.val == root2.val) {
            return match(root1.left, root2.left) && match(root1.right, root2.right);
        }
        // 结点值不相等返回false
        return false;
    }
    
}
```

##### 2，树的镜像

> 题目：操作给定的二叉树，将其变换为源二叉树的镜像
>
> 思路：若树左右都为空，则不用进行镜像操作；若树直接为空，也不用操作`这两种情况都是直接return`；
>
> 否则：需要先进行左右子树的直接交换，然后再对其左右进行递归Mirror操作

```java
  public void Mirror(TreeNode root) {
        if(root==null)return;
        if(root.left==null&&root.right==null)return;
        if(root.left!=null||root.right!=null){
           TreeNode dev=null;
            dev=root.left;
            root.left=root.right;
            root.right=dev;
            Mirror(root.left);
            Mirror(root.right);
        }
    }
```

##### 3，二叉树的所有路径

[参考1](<https://www.jianshu.com/p/71271d7ba0f4>)

[参考2](<https://blog.csdn.net/orz_713/article/details/64440706>)

### 12,二维数组

##### 1，顺时针打印二维数组成员

> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字

```java
public class Solution {
    public ArrayList<Integer> printMatrix(int [][] matrix) {
     if(matrix.length==0||matrix==null){
           return null;
       }
        ArrayList<Integer> list=new ArrayList<Integer>();
        int row=matrix.length;//行数
        int col=matrix[0].length;//列数
        int start=0;
        while(row>start*2&&col>start*2){//循环可以持续的条件
            int Xmax=row-1-start;
            int Ymax=col-1-start;
           
            for(int i=start;i<=Ymax;i++){
                list.add(matrix[start][i]);//从左到右
            }
            if(start<Xmax){
                for(int j=start+1;j<=Xmax;j++){//从右上到右下
                list.add(matrix[j][Ymax]);
              }
            }
            if(start<Ymax&&start<Xmax){
                 for(int k=Ymax-1;k>=start;k--){//右下到左下
                list.add(matrix[Xmax][k]);
              }
            }
            if(start<Ymax&&start<Xmax-1){
              for(int n=Xmax-1;n>start;n--){//左下到左上
                list.add(matrix[n][start]);
              }  
            }
            start++;
        }return list;
    }
```

### 13，栈

##### 1，求栈所含最小元素

>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）

```java

    Stack<Integer> data=new Stack<Integer>();
    Stack<Integer> mins=new Stack<Integer>();
    Integer tmpMin=null;//用temMin来存储临时最小值
//数据入栈，并与最小值判断大小    
public void push(int node) {
        if(tmpMin == null) {
            tmpMin = node;
            data.push(node);
            mins.push(node);
        } else {
            if(node <= tmpMin) {
                tmpMin = node;
                mins.push(node);
            }
            data.push(node);
        }
    }
    //弹出栈顶元素
    public void pop() {
           int po= data.pop();
           int min=mins.pop();
            if(po!=min){
                 mins.push(min);
            }
    }
    //查看栈顶元素
    public int top() {
        int to=data.pop();
        data.push(to);
        return to;
    }
    //查找栈中最小元素
    public int min() {
        int mi=mins.pop();
        mins.push(mi);
        return mi;
    }
```

##### 2，出栈顺序

> 说明当栈不为空且栈顶数据和当前pop序列中的数据不相等时循环结束

### 14，nextLine()的一些应用说明

>当nextLine()和其他的Next()连用的时候，会出现自动读取之前输入的**回车键**作为nextLine结束符！
>
>nextLine()自动读取了被next()去掉的Enter作为他的结束符，所以没办法给s2从键盘输入值。经过验证，我发现其他的next的方法，如double nextDouble()  ， float nextFloat() ， int nextInt() 等与nextLine()连用时都存在这个问题，
>
>### 解决的办法：在每一个 next()、nextDouble()  、 nextFloat()、nextInt() 等语句之后加一个**nextLine()**语句，将被next()去掉的Enter结束符过滤掉。

### 15，数据结构简单总结

##### a，队列

> 队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。

单队列：

![1556245019016](C:\Users\Lakers\AppData\Roaming\Typora\typora-user-images\1556245019016.png)

![1556244786948](C:\Users\Lakers\AppData\Roaming\Typora\typora-user-images\1556244786948.png)

循环队列：rear = (rear - size) % size

![1556245091579](C:\Users\Lakers\AppData\Roaming\Typora\typora-user-images\1556245091579.png)

队满标志：(rear+1)%size==front（会空一格）

![1556246407968](C:\Users\Lakers\AppData\Roaming\Typora\typora-user-images\1556246407968.png)

队列个数统计：

当rear>front，个数等于rear-front

当front>rear,个数等于rear-front+size

**Java 集合中的 Queue** 继承自 [Collection 接口](http://blog.csdn.net/u011240877/article/details/52773577) ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。

添加：	add(  ) ,offer( )在尾部添加，不能加null元素

删除：    remove(), poll() 删除并返回头部

获取：    element(), peek() 获取但不删除

### 16，数学函数

Math.pow(a,3)：即等于求a的3次方，Math方法直接是在Java.lang

Character.valueOf( )：输出字符的asc码值，0-48，A对应65，a对应97

### 17，转义字符

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/lab.png)

![md文件名格式](https://github.com/rodyyyy/rodyyyy.github.io/raw/master/images/lab2.png)

### 18,树的前序，中序，后序的递归与非递归遍历

> 非递归用栈

##### 1，前序

```java
/*class BinaryTree{  
public int value;  
public BinaryTree leftNode;  
public BinaryTree rightNode;  
BinaryTree(int x) { value = x; }  
} */

//递归
void preOrder(BinaryTree root){
	if(root !=null){
	System.out.println(root.value);
	preOrder(root.left);
	preOrder(root.right);
	}
}
//非递归
public static ArrayList<Integer> preOrder(TreeNode root){
        Stack<TreeNode> stack = new Stack<TreeNode>();
        ArrayList<Integer> list = new ArrayList<Integer>();
        if(root == null){
            return list;
        }
        stack.push(root);
        while(!stack.empty()){
            TreeNode node = stack.pop();
            list.add(node.data);
            if(node.rightNode!=null){
                stack.push(node.rightNode);
            }
            if(node.leftNode!= null){
                stack.push(node.leftNode);
            }

        }
        System.out.println(list);
        return list;
    }
//递归
private void traversal(TreeNode root, List<Integer> results) {
        if (root == null) {
            return;
        }
        results.add(root.val);
        traversal(root.left, results);
        traversal(root.right, results);
    }
}

```



##### 2，中序

[参考](<https://www.jianshu.com/p/3dda8f348cd0>)

```java
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
//非递归
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Inorder in ArrayList which contains node values.
     */
    public ArrayList<Integer> inorderTraversal(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        ArrayList<Integer> result = new ArrayList<Integer>();
        TreeNode curt = root;
        // curt == null && stack 非空 说明当前结点为二叉树叶子结点，中序遍历还未结束
        while (curt != null || !stack.empty()) {
            while (curt != null) {
                // 一直找，找到最左边结点，即中序遍历输出的第一个结点
                stack.push(curt);
                curt = curt.left;
            }
            // 此时当前结点的左儿子已经为空
            curt = stack.pop();
            result.add(curt.val);
            /* 当前结点的右儿子如果为空，证明当前结点是叶子结点则会进入下一轮while循环，
             * 当栈不为空时会 pop 出当前结点的根结点，curt 指向新的结点
             */
            curt = curt.right;
        }
        return result;
    }
}
//递归
public class Solution {
    /*
     * @param root: A Tree
     * @return: Inorder in ArrayList which contains node values.
     */
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> results = new ArrayList<>();
        traversal(root, results);
        return results;
    }
    
    private void traversal(TreeNode root, List<Integer> results) {
        if (root == null) {
            return;
        }
        
        traversal(root.left, results);
        results.add(root.val);
        traversal(root.right, results);
    }
}
//递归+遍历
public class Solution {
    /*
     * @param root: A Tree
     * @return: Inorder in ArrayList which contains node values.
     */
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> results = new ArrayList<>();
        
        if (root == null) {
            return results;
        }
        
        List<Integer> left = inorderTraversal(root.left);
        List<Integer> right = inorderTraversal(root.right);
        
        results.addAll(left);
        results.add(root.val);
        results.addAll(right);
        
        return results;
    }
}
//分治+递归
public class Solution {
    /*
     * @param root: A Tree
     * @return: Inorder in ArrayList which contains node values.
     */
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> results = new ArrayList<>();
        
        if (root == null) {
            return results;
        }
        
        List<Integer> left = inorderTraversal(root.left);
        List<Integer> right = inorderTraversal(root.right);
        
        results.addAll(left);
        results.add(root.val);
        results.addAll(right);
        
        return results;
    }
}
```

##### 3，后序

```java
//非递归
//参考1：
public static void postorderfun(BTree root){
		Stack<BTree> stack =new Stack<BTree>();
		BTree proot;//标记栈顶元素前一个被访问的元素
		int flag;//root的左孩子未被访问；
		if(root!=null){
			do{
				while(root!=null){//将root所有左孩子全部入栈
					stack.push(root);
					root=root.left;
				  }
				
				//执行到此处，栈顶元素没有左孩子或者左子树已经被访问过；
				proot=null;//标记栈顶元素前一个被访问的元素，或者此时为最左下边，该元素前一个被访问的元素肯定为空。
				flag=1;//root的左孩子已经被访问；或者root为null
				
				while(!stack.isEmpty() && flag==1){
					root=stack.peek();       //取到栈顶元素，但是不出栈；
					if(root.right==proot){
						root=stack.pop();
						System.out.print(root.value+"  ");
						proot=root;
					}else{
						root=root.right;
						flag=0;//root左边孩子未被访问；
					}
				}
			}while(!stack.isEmpty());
		}
//参考2
     public void behindOrder2(Tree root){
            if(root==null)
                return;
            Stack<Tree> s = new Stack<Tree>();

            Tree curNode; //当前访问的结点
            Tree lastVisitNode; //上次访问的结点
            curNode = root;
            lastVisitNode = root;

            //把currentNode移到左子树的最下边
            while(curNode!=null){
                s.push(curNode);
                curNode = curNode.left_child;
            }
            while(!s.empty()){
                curNode = s.pop();  //弹出栈顶元素
                //一个根节点被访问的前提是：无右子树或右子树已被访问过
                if(curNode.right_child !=null && curNode.right_child != lastVisitNode){
                    //根节点再次入栈
                    s.push(curNode);
                    //进入右子树，且可肯定右子树一定不为空
                    curNode = curNode.right_child;
                    while(curNode!=null){
                        //再走到右子树的最左边
                        s.push(curNode);
                        curNode = curNode.left_child;
                    }
                }
                else{
                    //访问
                    System.out.print(curNode.val+" " );
                    //修改最近被访问的节点
                    lastVisitNode = curNode;
                }
            } //while
        }
//递归
     private void traversal(TreeNode root, List<Integer> results) {
        if (root == null) {
            return;
        }
        
        traversal(root.left, results);
        traversal(root.right, results);
        results.add(root.val);
    }
```

### 19，树的一些操作

##### 1，求深度

[参考](<https://www.jianshu.com/p/bc31fb7b7f2c>)

